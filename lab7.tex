\section{کارگاه اسمبلی اول}

\subsection{اهداف آزمایش}
\begin{itemize}
    \item راه‌اندازی محیط اجرای برنامه های \lr{ARMv7}
    \item آشنایی با قواعد نحوی اسمبلر \lr{GCC}
    \item آشنایی مقدماتی با برنامه نویسی به زبان اسمبلی \lr{ARMv7}
    
\end{itemize}

\subsection{قطعات مورد نیاز}
\begin{itemize}
    \item کامپیوتر متصل به اینترنت و یا کامپیوتری که سیستم عامل لینوکس دارد
\end{itemize}

\subsection{مقدمه}

\paragraph{
همانطور که از اسم درس «آزمایشگاه ریزپردازنده و اسمبلی» پیداست، قسمتی از مباحث ما مربوط به زبان اسمبلی و به طور خاص اسمبلی معماری آرم است.
در کارگاه های آینده زبان اسمبلی را تمرین می‌کنیم و تلاش می‌کنیم که تسلط کافی بر این مبحث داشته باشیم
}

\subsection{راه اندازی محیط اجرا}
\paragraph{
از آنجایی که کامپیوتر های ما معمولا یکی از معماری های
\lr{x86_64}
و 
\lr{ARM64}
هستند باید روشی برای اجرای برنامه های آرم ۳۲ بیتی داشته باشیم. پیشنهاد ما استفاده از
\href
{https://cpulator.01xz.net/?sys=arm}
{
سایت
\lr{CPUlator}
}
است. با استفاده از این سایت می‌توانیم مستقیما برنامه اسمبلی خود را بنویسیم و آن را خط به خط اجرا کنیم و مقادیر رجیستر ها را ببینیم. 
در صورتی که دسترسی به اینترنت ندارید می‌توانید از شبیه‌ساز \lr{QEMU} استفاده کنید اما راه اندازی و استفاده آن مقداری سخت تر است. می‌توانید از این لینک برای آموزش استفاده کنید. توجه کنید که هدف ما آرم ۳۲ بیتی و نه آرم ۶۴ بیتی است.
}

\subsection{آشنایی با قواعد نحوی اسمبلر \lr{GCC}}
\paragraph{
سایت \lr{CPUlator} از اسمبلر \lr{GCC} استفاده می‌کند. در این اسمبلر، نحوه استفاده از دایرکتیو ها مقداری متفاوت از اسمبلر \lr{ARMASM} است که در کلاس تدریس شد. هرچند می‌توانید خودتان برنامه ها را با استفاده از اسمبلر \lr{ARMASM} اسمبل کنید. آموزش انجام این کار را می‌توانید در این لینک ببینید.
}

\paragraph{
خوشبختانه اسامی دستور ها بین این دو اسمبلر یکسان است. تفاوت بزرگ در کدی که می‌نویسید این است که کامنت ها در اسمبلر \lr{GNU} با استفاده از کاراکتر \lr{@} است. همچنین نیازی به \lr{Indentation} صحیح ندارید، اما برای خوانایی کد توصیه می‌شود که آن را رعایت کنید.
}

\subsubsection{لیست دایرکتیو های \lr{GCC} و تفاوت های آن با \lr{ARMASM}}

\begin{itemize}
    \item \lr{.ascii "<string>"} بایت های یک رشته را در برنامه قرار می‌دهند. این دایرکتیو مشابه با دایرکتیو \lr{DCB} است.
    \item \lr{.asciiz "<string>"} مشابه با دایرکتیو \lr{.ascii} با این تفاوت که یک بایت صفر در پایان رشته قرار می‌دهد.
    \item \lr{.byte <byte1>, <byte2>, ...} مشابه با دایرکتیو \lr{DCB}. اسمبلر مقادیر یک بایتی را در برنامه قرار می‌دهد.
    \item \lr{.hword <short1> , <short2>, ...} مشابه با دایرکتیو \lr{DCW}. اسمبلر مقادیر ۲ بایتی را در برنامه قرار می‌دهد.
    \item \lr{.word <word1>, <word2>, ...} مشابه با دایرکتیو \lr{DCD}. اسمبلر مقادیر ۴ بایتی را در برنامه قرار می‌دهد.
    \item \lr{.equ <symbol name>, <value>} مشابه با دایرکتیو \lr{EQU}. اسمبلر یک سمبل تعریف می‌کند و مقدار آن را برابر با مقداری که گذاشتید می‌کند.
    
    \item \lr{.balign <power\_of\_2>{,<fill\_value> ,<max\_padding>} }: آدرس کد یا داده‌ای که پس از این دایرکتیو می‌آید را هم ردیف یک توانی از ۲ می‌کند. برای مثال اگر کد یا داده بعد از آن باید در آدرس ۳ می‌آمد و از اسمبلر خواستیم که آن را هم ردیف ۸ بکند، اسمبلر ۵ بایت اضافه به عنوان \lr{Padding} قبل از آن اضافه می‌کند. این دایرکتیو دو آرگومان اضافه دارد که اولی مقدار بیت های پدینگ را مشخص می‌کند. در صورتی که این آرگومان را نذاشتید بایت صفر به عنوان پدینگ قرار می‌گیرد. آرگومان بعدی حداکثر مقدار بایت های پدینگ را مشخص می‌کند که اگر بایت های پدینگی که باید اضافه می‌شد بیشتر از آن بود اسمبلر کد یا داده بعد از دایرکتیو را هم ردیف نمی‌کند و دایرکتیو بی اثر می‌شود.

\end{itemize}

\subsection{دستور کارگاه}

\paragraph{
همردیف با \lr{n} شدن یعنی اینکه آدرس داده یا کد ما بر \lr{n} بخش‌پذیر باشد. برای مثال همردیف با ۲ یعنی آدرس ما ۰، ۲ ، ۴ و ... باشد. در این کارگاه ابتدا با همردیفی و اهمیت آن و نحوه انجام آن آشنا می‌شویم و سپس یک برنامه ساده برای آشنایی با زبان اسمبلی و نحوه خواندن و نوشتن حافظه در معماری آرم می‌نویسیم.
}

\subsubsection{آشنایی با \lr{alignment} و اهمیت آن}
\begin{itemize}
    \item در بالای کد اسمبلی، رشته \lr{"hello"} را قرار دهید.
    \item بایت های ۱ و ۲ و ۳ را پس از آن قرار دهید.
    \item برنامه را کامپایل کنید و ترتیب قرار گیری رشته و بایت ها و آدرس آن ها را در حافظه ببینید.
    \item با استفاده از دایرکتیو \lr{.balign 13} در میان رشته و بایت ها، تلاش کنید که آدرس بایت ۱ هم ردیف با ۱۳ شود.
    \item تلاش کنید کد را کامپایل کنید. دلیل اروری را که می‌گیرید توضیح دهید.
    \item مقدار \lr{.balign} را به ۴ تغییر دهید. و کد را دوباره کامپایل کنید. چه تفاوتی در ترتیب قرار گیری رشته و بایت ها می‌بینید؟
    \item بعد از لیبل \lr{\_start:} کدی بنویسید که مقدار ۲ را درون رجیستر \lr{r0} قرار دهد و سپس \lr{r0} را با \lr{r0} جمع کند و درون \lr{r1} قرار دهید.
    \item اگر کد را کامپایل کنید هنگام اجرا به یک ارور برخواهید خورد. دلیل این ارور چیست؟
    \item برای حل این مشکل، شروع کدی که نوشتید را هم ردیف با ۴ کنید. کد را دوباره اجرا کنید و با مشاهده مقدار رجیستر ها در اجرای خط به خط برنامه، تایید کنید که همان اتفاقی می‌افتد که می‌خواستیم.
\end{itemize}

\subsubsection{نوشتن یک برنامه ساده اسمبلی}
در این قسمت می‌خواهیم رشته \lr{"hello"} را به \lr{"HELLO"} تغییر بدهیم. در این قسمت از حلقه استفاده نخواهیم کرد و صرفا کد را تکرار می‌کنیم.
\begin{itemize}
    \item ابتدا باید آدرس شروع رشته را بدانیم. برای این کار باید از لیبل ها استفاده کنیم. یکی از لیبل هایی که در کد شما وجود دارد لیبل \lr{\_start:} است. هنگامی که برنامه اسمبل و لینک می‌شود آدرس شروع اجرای برنامه برابر با آدرسی که لیبل \lr{\_start} نشان می‌دهد می‌شود.
    \item لیبل ها در زبان اسمبلی آرم، یک اسم هستند که پس آن : می‌آید. اسمبلر در هنگام اسمبل کردن برنامه شما هر جا که لیبل را دید با آدرس کد یا داده‌ای که پس از لیبل آمده جایگزین می‌کند. برای مثال برای اینکه بخواهیم آدرس شروع رشته را بدانیم کافیست قبل از تعریف رشته یک لیبل اضافه کنیم. این کار را با اسم دلخواه خود انجام بدهید.
    \item برنامه ما باید کاراکتر های رشته را تک تک از حافظه بخواند، مقدار آن را تغییر دهد و مقدار تغییر یافته را در همان آدرس حافظه دوباره بنویسد.
    \item برای خواندن از حافظه، ابتدا باید آدرس لیبل را درون رجیستر \lr{r0} یا هر رجیستر دیگری که می‌خواهید قرار دهید. برای این کار می‌توانید از دستور \lr{MOV} استفاده کنید.
    \item با استفاده از دستور \lr{LDRB} خانه‌ای از حافظه که آدرس آن را \lr{r0} قرار دارد را در \lr{r1} قرار دهید.
    \item برای تبدیل کاراکتر کوچک اسکی به کاراکتر بزرگ، کافیست ۳۲ تا از مقدار کاراکتر کم کنیم. این کار را با استفاده از دستورات جمع و یا تفریق انجام بدهید.
    \item حال باید کاراکتر را در حافظه بنویسیم. آدرس حافظه همچنان در \lr{r0} قرار دارد و کاراکتر تبدیل یافته نیز در \lr{r1} است. با استفاده از دستور \lr{STRB} کاراکتر تبدیل یافته را در حافظه بنویسید.
    \item حال سراغ کاراکتر بعدی می‌رویم. آدرس کاراکتر بعدی یکی از آدرسی که در \lr{r0} قرار دارد بیشتر است، پس کافیست یکی به \lr{r0} اضافه کنیم و مراحل قبل را تکرار کنیم.
    \item این کار را برای هر ۵ کاراکتر رشته تکرار کنید.
    \item برنامه را اجرا کنید و با مشاهده مقادیر رجیستر ها و خانه های حافظه، تایید کنید که برنامه درست کار می‌کند.
\end{itemize}