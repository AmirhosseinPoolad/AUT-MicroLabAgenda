\section{کارگاه اسمبلی سوم}

\subsection{اهداف آزمایش}
\begin{itemize}
    \item آشنایی با نحوه تعریف و کار با ساختار ها در زبان اسمبلی
    \item آشنایی با نحوه تعریف و کار با توابع در زبان اسمبلی
    \item آشنایی با مفهوم \lr{ABI} و لزوم استفاده از آن
\end{itemize}

\subsection{قطعات مورد نیاز}
\begin{itemize}
    \item کامپیوتر متصل به اینترنت و یا کامپیوتری که سیستم عامل لینوکس دارد
\end{itemize}

\subsection{مقدمه}

\paragraph{
در ادامه آشنایی با برنامه‌نویسی به زبان اسمبلی، با ساختار ها و توابع در زبان اسمبلی آشنا خواهیم شد. از آنجا که در اسمبلی صرفا با بایت ها و آدرس ها کار داریم و مفاهیمی مانند تابع و ساختار اساسا وجود ندارند، باید با قواعدی که کامپایلر ها برای پیاده‌سازی این تعاریف استفاده می‌کنند آشنا شویم. این قواعد قسمتی از چیزی هستند که به آن \lr{Appication Binary Interface} گفته می‌شود.
}

\subsubsection{آشنایی با نحوه تعریف و کار با ساختار ها در زبان اسمبلی}

\paragraph{
ساختار یا استراکت یک مفهوم در برخی زبان‌های برنامه نویسی سطح بالا بود که در آن برخی اطلاعات مرتبط به هم را در کنار یک دیگر نگه می‌داشتیم. در زبان اسمبلی ما با بایت ها سر و کار داریم و همانطور که در کارگاه اول دیدیم، هر گاه می‌خواستیم \lr{n} بایت داده بخوانیم، باید آدرس داده‌ها هم‌ردیف با \lr{n} باشد. این مسئله در واقع دلیل قواعد مربوط به چینش استراکت در زبان \lr{C} بود که با آن در درس مبانی برنامه‌نویسی آشنا شدید.
}

\paragraph{برای یادآوری، و همچنین برای استفاده مجدد، این قواعد را در اینجا بازگو می‌کنیم:}

\begin{itemize}
    \item هر فیلد از استراکت، هم‌ردیف با اندازه خودش است.
    \item اندازه کل یک استراکت مضربی از اندازه بزرگ‌ترین فیلد آن است.
    
\end{itemize}

\subsubsection{آشنایی با نحوه تعریف و کار با توابع در زبان اسمبلی}

\paragraph{مانند بقیه چیزهایی که در زبان‌های برنامه‌نویسی سطح بالا داشتیم، تابع نیز در زبان اسمبلی وجود ندارد. در واقع ما در زبان اسمبلی تنها روشی که برای تغییر روند اجرای کد داریم برنچ است. برای اینکه بدانیم توابع سطح بالا پس از کامپایل چه فرمی دارند تا ما نیز از همان فرم استفاده کنیم باید با قواعد مربوطه آشنا شویم. قواعد اصلی آن در کلاس درس به عنوان استاندارد \lr{AAPCS} معرفی شد. در کارگاه از یک نسخه ساده‌سازی شده این قواعد استفاده خواهیم کرد.}

\paragraph{
نکته اصلی قاعده مربوط به صدا زدن توابع این است که ما رجییستر ها را به دو بخش تقسیم می‌کنیم، رجیستر هایی که حفظ آن‌ها وظیفه صدا زننده تابع است، و رجیستر هایی که حفظ آن‌ها وظیفه تابع صدا زده شده است. برای مثال اگر بگوییم \lr{r0} را صدا زننده حفظ کند و \lr{r1} را صدا زده شده، برنامه ما قبل از صدا زدن تابع باید \lr{r0} را در استک قرار دهد و تابع نیز اگر از \lr{r1} استفاده می‌کند باید آن‌را در استک قرار دهد و قبل از پایان تابع مقدار اصلی آن‌را باز گرداند.
}

\paragraph{در این کارگاه قرارداد می‌کنیم که رجیسترهای صفر تا سوم را صدا زننده تابع حفظ کند، و رجیستر های چهارم تا دوازدهم به علاوه رجیستر \lr{lr} را تابع صدا زده شده حفظ کند. باقی رجیسترها خاص منظوره‌اند و نباید از آن‌ها استفاده کنید. برای هر کدام از توابع خود باید یک لیبل بگذارید و صدا زدن تابع نیز با استفاده از دستور \lr{bl} و برگشتن از تابع با استفاده از دستور \lr{bx lr} صورت می‌گیرد.}

\paragraph{اما آرگومان های ورودی توابع چگونه به ورودی داده می‌شوند؟ این نیز در استاندارد \lr{AAPCS} گفته شده. در این کارگاه قرارداد می‌کنیم که از رجیستر های صفر تا چهارم برای ورودی‌ها استفاده کنیم. مقدار خروجی نیز در رجیستر صفر قرار می‌گیرد.}

\paragraph{
در نتیجه برای توابع باید نکات زیر را رعایت کنید:
}
\begin{itemize}
    \item برای صدا زدن تابع ابتدا رجیستر های صفر تا سه را در استک حفظ کنید، سپس آرگومان های ورودی را به ترتیب در رجیستر های صفر تا سه قرار دهید، تابع را صدا بزنید، مقدار خروجی تابع را نگه‌دارید و سپس رجیستر صفر تا سوم را از استک برگردانید.
    \item تابعی که صدا زده می‌شود حق دارد بدون حفظ کردن در استک از رجیستر های صفر تا سه استفاده کند.
    \item تابعی که صدا زده می‌شود باید رجیستر \lr{lr} را ابتدای تابع در استک حفظ کند و قبل از بازگشت از تابع آن را از استک برگرداند.
    \item در صورتی که از رجیستر های چهارم تا دوازدهم در تابع استفاده شد، تابع باید آن‌ها را ابتدای اجرا در استک حفظ کند و قبل از بازگشت از تابع آن ها را از استک برگرداند.
\end{itemize}

\subsection{دستور کارگاه}


\begin{itemize}
    \item یک تابع برای به توان دو رساندن بنویسید و با استفاده از قراردادی که داشتیم، آن را به درستی صدا بزنید.
    \item یک تابع بازگشتی بنویسید که یک عدد \lr{n} به عنوان ورودی بگیرد و عدد \lr{n}ام فیبوناچی را در خروجی بازگرداند.
    \item در فایل 
    \lr{data.asm}
    یک درخت با شما داده شده است که ۴ بایت اول آن مقدار داده درخت، ۴ بایت بعدی فرزند راست و ۴ بایت بعدی فرزند چپ درخت است. با دایرکتیو 
    \lr{.space <number\_of\_bytes>}
    هفت ورد فضا رزرو کنید، به صورت 
    \lr{Post-Order}
    در درخت پیمایش کنید و مقادیر گره های درخت را در فضایی که رزرو کردید بنویسید.
\end{itemize}


کد پیمایش درخت:
\begin{latin}
\begin{lstlisting}
struct tree{
    int val;
    struct tree *right;
    struct tree *left;
}
void post_order(struct tree *root){
    if(root == 0) return;
    post_order(root->left);
    post_order(root_right);
    print(root->val); //store in reserved space instead of printing
}
\end{lstlisting}
\end{latin}